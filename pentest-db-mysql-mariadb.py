#!/usr/bin/env python3
"""
Clean MySQL Process Monitor
Vers√£o limpa - s√≥ captura e salva em arquivo
"""

import mysql.connector
import time
import threading
from datetime import datetime
import argparse

class CleanMonitor:
    def __init__(self, host, user, password, database=None, port=3306):
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.port = port
        self.seen_processes = set()
        self.running = False
        self.captured_count = 0
        self.log_file = f"mysql_captures_{datetime.now().strftime('%Y%m%d_%H%M%S')}.log"

    def connect(self):
        """Get database connection"""
        try:
            return mysql.connector.connect(
                host=self.host,
                user=self.user,
                password=self.password,
                database=self.database,
                port=self.port,
                buffered=True
            )
        except Exception as e:
            print(f"‚ùå Connection failed: {e}")
            return None

    def is_sensitive(self, info):
        """Check if query contains sensitive data"""
        if not info:
            return False

        info_lower = str(info).lower()

        # Skip monitoring queries
        if 'processlist' in info_lower:
            return False

        # Look for sensitive keywords
        keywords = ['password', 'admin', 'secret', 'username', 'token', 'auth', 'login']
        return any(keyword in info_lower for keyword in keywords)

    def log_capture(self, process_data):
        """Log captured query to file and console"""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        # Console output (minimal)
        print(f"üéØ [{timestamp}] Captured from {process_data['user']}@{process_data['host']}")

        # File output (detailed)
        log_entry = f"""
{'='*80}
TIMESTAMP: {timestamp}
PID: {process_data['pid']}
USER: {process_data['user']}
HOST: {process_data['host']}
DATABASE: {process_data['db']}
COMMAND: {process_data['command']}
QUERY: {process_data['info']}
{'='*80}
"""

        with open(self.log_file, 'a', encoding='utf-8') as f:
            f.write(log_entry)

    def monitor_worker(self):
        """Main monitoring worker"""
        conn = self.connect()
        if not conn:
            print("‚ùå Failed to connect")
            return

        try:
            while self.running:
                cursor = conn.cursor()
                cursor.execute("""
                    SELECT ID, USER, HOST, DB, COMMAND, TIME, INFO
                    FROM information_schema.PROCESSLIST
                    ORDER BY TIME DESC
                """)
                processes = cursor.fetchall()
                cursor.close()

                for process in processes:
                    pid, user, host, db, cmd, exec_time, info = process

                    # Create unique signature
                    signature = f"{pid}:{user}:{cmd}:{info}"

                    if signature not in self.seen_processes:
                        self.seen_processes.add(signature)

                        # Check if sensitive
                        if self.is_sensitive(info):
                            self.captured_count += 1

                            process_data = {
                                'pid': pid,
                                'user': user,
                                'host': host,
                                'db': db or 'NULL',
                                'command': cmd,
                                'info': info,
                                'time': exec_time
                            }

                            self.log_capture(process_data)

                time.sleep(0.01)  # 10ms between checks

        except Exception as e:
            print(f"‚ùå Monitor error: {e}")
        finally:
            conn.close()

    def start_monitoring(self, duration=300):
        """Start monitoring"""
        print(f"üîç MySQL Process Monitor")
        print(f"Target: {self.host}:{self.port}")
        print(f"User: {self.user}")
        print(f"Duration: {duration}s")
        print(f"Log file: {self.log_file}")
        print(f"Looking for sensitive queries...\n")

        # Test connection
        test_conn = self.connect()
        if not test_conn:
            return
        test_conn.close()
        print("‚úÖ Connection OK")

        self.running = True

        # Start monitoring thread
        monitor_thread = threading.Thread(target=self.monitor_worker)
        monitor_thread.daemon = True
        monitor_thread.start()

        start_time = time.time()

        try:
            # Status updates every 30 seconds
            while self.running and (time.time() - start_time) < duration:
                time.sleep(30)
                elapsed = int(time.time() - start_time)
                remaining = duration - elapsed
                print(f"üìä Running: {elapsed}s | Remaining: {remaining}s | Captured: {self.captured_count}")

        except KeyboardInterrupt:
            print(f"\n‚èπÔ∏è  Stopped by user")
        finally:
            self.running = False
            monitor_thread.join(timeout=2)

            print(f"\nüèÅ Monitoring completed!")
            print(f"üìà Total captures: {self.captured_count}")
            print(f"üìÑ Log file: {self.log_file}")

def main():
    parser = argparse.ArgumentParser(description='Clean MySQL Process Monitor')
    parser.add_argument('--host', default='192.168.29.11', help='MySQL host')
    parser.add_argument('--port', type=int, default=3306, help='MySQL port')
    parser.add_argument('--user', default='webapp', help='MySQL user')
    parser.add_argument('--password', default='webapp123', help='MySQL password')
    parser.add_argument('--database', default='testdb', help='MySQL database')
    parser.add_argument('--duration', type=int, default=300, help='Duration in seconds')

    args = parser.parse_args()

    monitor = CleanMonitor(
        host=args.host,
        user=args.user,
        password=args.password,
        database=args.database,
        port=args.port
    )

    monitor.start_monitoring(args.duration)

if __name__ == "__main__":
    main()
